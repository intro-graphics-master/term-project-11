<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <title>Final_Project</title>
    <link rel="icon" href="src/images/fav.ico">
    <style>
        body {
            background-color: #bfd1e5;
            color: #61443e;
            margin: 0;
            height: 100vh;
            width: 100vh;
        }

        a {
            color: #a06851;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <div id="container">
        <div style="position: fixed; top: 0px; left: 0px; cursor: pointer; opacity: 0.9; z-index: 10000;">
            <canvas width="80" height="48" style="width: 80px; height: 48px; display: block;"></canvas>
            <canvas width="80" height="48" style="width: 80px; height: 48px; display: none;"></canvas>
            <canvas width="80" height="48" style="width: 80px; height: 48px; display: none;"></canvas>
        </div>
    </div>
    <script src="src/three.js"></script>
    <script src="src/OrbitControls.js"></script>
    <script src="src/ImprovedNoise.js"></script>
    <script src="src/WebGL.js"></script>
    <script src="src/stats.min.js"></script>
    <script src="src/Sky.js"></script>
    <script src="src/Water.js"></script>
    <script src="src/dat.gui.min.js"></script>



    <script>

        var container, stats;

        var camera, controls, scene, renderer, light;

        var mesh, texture;

        var water;

        var worldWidth = window.innerWidth, worldDepth = window.innerHeight,
            worldHalfWidth = worldWidth / 2, worldHalfDepth = worldDepth / 2;

        var clock = new THREE.Clock();

        container = document.getElementById('container');

        camera = new THREE.PerspectiveCamera(100, window.innerWidth / window.innerHeight, 0.01, 20000);
        camera.position.set(30, 30, 100);


        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xbfd1e5);
        //FOG
        scene.fog = new THREE.FogExp2(0xefd1b5, 0.0002);

        light = new THREE.DirectionalLight(0xffffff, 0.8);
        scene.add(light);

        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.maxPolarAngle = Math.PI * 0.495;
        controls.target.set(0, 10, 0);
        controls.minDistance = 40.0;
        controls.maxDistance = 200.0;
        controls.update();


        stats = new Stats();
        container.appendChild(stats.dom);

        window.addEventListener('resize', onWindowResize, false);

        document.addEventListener('touchstart', function (event) {
            if (event.cancelable) {
                if (!event.defultPrevented) {
                    event.preventDefault();
                }
            }

        }, false);

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

            controls.handleResize();

        }





        Terraininit();
        Sky_Waterinit();
        //Cloud_raininit();
        animate();





        function Terraininit() {

            var Terriandata = generateHeight(worldWidth, worldDepth);

            camera.position.y = Terriandata[worldHalfWidth + worldHalfDepth * worldWidth] * 10 + 500;

            var geometry = new THREE.PlaneBufferGeometry(12500, 12500, worldWidth - 1, worldDepth - 1);
            geometry.rotateX(- Math.PI / 2);

            var vertices = geometry.attributes.position.array;

            for (var i = 0, j = 0, l = vertices.length; i < l; i++ , j += 3) {

                vertices[j + 1] = Terriandata[i] * 10 - 750;

            }

            texture = new THREE.CanvasTexture(generateTexture(Terriandata, worldWidth, worldDepth));
            texture.wrapS = THREE.ClampToEdgeWrapping;
            texture.wrapT = THREE.ClampToEdgeWrapping;

            mesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ map: texture }));
            scene.add(mesh);

        }



        function generateHeight(width, height) {

            var size = width * height, Terriandata = new Uint8Array(size),
                perlin = new THREE.ImprovedNoise(), quality = 1, z = Math.random() * 100;

            for (var j = 0; j < 4; j++) {

                for (var i = 0; i < size; i++) {

                    var x = i % width, y = ~ ~(i / width);
                    Terriandata[i] += Math.abs(perlin.noise(x / quality, y / quality, z) * quality * 1.75);

                }

                quality *= 5;

            }

            return Terriandata;

        }



        function generateTexture(Terriandata, width, height) {

            var canvas, canvasScaled, context, image, imageData, vector3, sun, shade;

            vector3 = new THREE.Vector3(0, 0, 0);

            sun = new THREE.Vector3(1, 1, 1);
            sun.normalize();

            canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;

            context = canvas.getContext('2d');
            context.fillStyle = '#000';
            context.fillRect(0, 0, width, height);

            image = context.getImageData(0, 0, canvas.width, canvas.height);
            imageData = image.data;

            for (var i = 0, j = 0, l = imageData.length; i < l; i += 4, j++) {

                vector3.x = Terriandata[j - 2] - Terriandata[j + 2];
                vector3.y = 2;
                vector3.z = Terriandata[j - width * 2] - Terriandata[j + width * 2];
                vector3.normalize();

                shade = vector3.dot(sun);

                imageData[i] = (96 + shade * 128) * (0.5 + Terriandata[j] * 0.007);
                imageData[i + 1] = (32 + shade * 96) * (0.5 + Terriandata[j] * 0.007);
                imageData[i + 2] = (shade * 96) * (0.5 + Terriandata[j] * 0.007);

            }

            context.putImageData(image, 0, 0);

            // Scaled 4x

            canvasScaled = document.createElement('canvas');
            canvasScaled.width = width * 4;
            canvasScaled.height = height * 4;

            context = canvasScaled.getContext('2d');
            context.scale(4, 4);
            context.drawImage(canvas, 0, 0);

            image = context.getImageData(0, 0, canvasScaled.width, canvasScaled.height);
            imageData = image.data;

            for (var i = 0, l = imageData.length; i < l; i += 4) {

                var v = ~ ~(Math.random() * 5);

                imageData[i] += v;
                imageData[i + 1] += v;
                imageData[i + 2] += v;

            }

            context.putImageData(image, 0, 0);

            return canvasScaled;

        }
        function Sky_Waterinit() {
            var waterGeometry = new THREE.PlaneBufferGeometry(10000, 10000);

            water = new THREE.Water(
                waterGeometry,
                {
                    textureWidth: 512,
                    textureHeight: 512,
                    waterNormals: new THREE.TextureLoader().load('src/images/Water_2_M_Normal.jpg', function (texture) {

                        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;

                    }),
                    alpha: 1.0,
                    sunDirection: light.position.clone().normalize(),
                    sunColor: 0xffffff,
                    waterColor: 0x001e0f,
                    distortionScale: 3.7,
                    fog: scene.fog !== undefined
                }
            );

            water.rotation.x = - Math.PI / 2;

            scene.add(water);

            // Skybox

            var sky = new THREE.Sky();

            var uniforms = sky.material.uniforms;

            uniforms['turbidity'].value = 10;
            uniforms['rayleigh'].value = 2;
            uniforms['luminance'].value = 1;
            uniforms['mieCoefficient'].value = 0.005;
            uniforms['mieDirectionalG'].value = 0.8;

            var parameters = {
                distance: 400,
                inclination: 0.49,
                azimuth: 0.205
            };

            var cubeCamera = new THREE.CubeCamera(0.1, 1, 512);
            cubeCamera.renderTarget.texture.generateMipmaps = true;
            cubeCamera.renderTarget.texture.minFilter = THREE.LinearMipMapLinearFilter;

            scene.background = cubeCamera.renderTarget;

            function updateSun() {

                var theta = Math.PI * (parameters.inclination - 0.5);
                var phi = 2 * Math.PI * (parameters.azimuth - 0.5);

                light.position.x = parameters.distance * Math.cos(phi);
                light.position.y = parameters.distance * Math.sin(phi) * Math.sin(theta);
                light.position.z = parameters.distance * Math.sin(phi) * Math.cos(theta);

                sky.material.uniforms['sunPosition'].value = light.position.copy(light.position);
                water.material.uniforms['sunDirection'].value.copy(light.position).normalize();

                cubeCamera.update(renderer, sky);

            }

            updateSun();

            // GUI

            var gui = new dat.GUI();

            var folder = gui.addFolder('Sky');
            folder.add(parameters, 'inclination', 0, 0.5, 0.0001).onChange(updateSun);
            folder.add(parameters, 'azimuth', 0, 1, 0.0001).onChange(updateSun);
            folder.open();

            var uniforms = water.material.uniforms;

            var folder = gui.addFolder('Water');
            folder.add(uniforms.distortionScale, 'value', 0, 8, 0.1).name('distortionScale');
            folder.add(uniforms.size, 'value', 0.1, 10, 0.1).name('size');
            folder.open();

        }


        function animate() {

            requestAnimationFrame(animate);
            render();
            stats.update();

        }



        function render() {
            var time = performance.now() * 0.001;

            controls.update(clock.getDelta());
            renderer.render(scene, camera);

            water.material.uniforms['time'].value += 1.0 / 60.0;

        }
    </script>

</body>
</html>
