<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <title>Final_Project</title>
    <link rel="icon" href="src/images/fav.ico">
    <style>
    body{
        margin: 0;
        height: 100vh;
        width: 100vh;
    }
    canvas{
        display:block;
    }
    </style>
</head>

<body>
    <div id="container"></div>
    <div style="position: fixed; top: 0px; left: 0px; cursor: pointer; opacity: 0.9; z-index: 10000;"></div>
    <script src = "src/three.js"></script>
    <script src = "src/OrbitControls.js"></script>
    <script src = "src/ImprovedNoise.js"></script>
    <script src = "src/WebGL.js"></script>
    <script src = "src/stats.min.js"></script>
    <script src = "src/Sky.js"></script>
    <script src = "src/Water.js"></script>
    <script src = "src/dat.gui.min.js"></script>

    <script>

var container, stats;
var camera, controls, scene, renderer,light;
var mesh, texture;
var water, cloud;
var flash, rain, rainGeo, rainCount = 15000;
let cloudParticles_w=[], cloudParticles_b=[];

var worldWidth = window.innerWidth, worldDepth = window.innerHeight,
worldHalfWidth = worldWidth / 2, worldHalfDepth = worldDepth / 2;

var clock = new THREE.Clock();

container = document.getElementById( 'container' );

//100
camera = new THREE.PerspectiveCamera( 100, window.innerWidth / window.innerHeight, 0.01, 20000 );
camera.position.set( 30, 30, 100 );

scene = new THREE.Scene();
scene.background = new THREE.Color( 0xbfd1e5 );
//FOG
scene.fog = new THREE.FogExp2( 0xefd1b5, 0.0002);

light = new THREE.DirectionalLight( 0xffffff, 0.8 );
scene.add( light );

renderer = new THREE.WebGLRenderer();
renderer.setPixelRatio( window.devicePixelRatio );
renderer.setSize( window.innerWidth, window.innerHeight );
container.appendChild( renderer.domElement );

controls = new THREE.OrbitControls( camera, renderer.domElement );
controls.maxPolarAngle = Math.PI * 0.495;
controls.target.set( 0, 10, 0 );
controls.minDistance = 40.0;
controls.maxDistance = 200.0;
controls.update();


stats = new Stats();
container.appendChild( stats.dom );

window.addEventListener( 'resize', onWindowResize, false );

document.addEventListener('touchstart', function(event){
    if (event.cancelable){
        if (!event.defultPrevented){
            event.preventDefault();
        }
    }

},false);

function onWindowResize() {

camera.aspect = window.innerWidth / window.innerHeight;
camera.updateProjectionMatrix();

renderer.setSize( window.innerWidth, window.innerHeight );

controls.handleResize();

}

Terraininit();
Sky_Waterinit();
Cloud_raininit();
//Cloud_snowinit();
animate();



function Terraininit() {

var Terriandata = generateHeight( worldWidth, worldDepth );

camera.position.y = Terriandata[ worldHalfWidth + worldHalfDepth * worldWidth ] * 10 + 500;

var geometry = new THREE.PlaneBufferGeometry( 12500, 12500, worldWidth - 1, worldDepth - 1 );
geometry.rotateX( - Math.PI / 2 );

var vertices = geometry.attributes.position.array;

for ( var i = 0, j = 0, l = vertices.length; i < l; i ++, j += 3 ) {

    vertices[ j + 1 ] = Terriandata[ i ] * 10 - 750;

}

texture = new THREE.CanvasTexture( generateTexture( Terriandata, worldWidth, worldDepth ) );
texture.wrapS = THREE.ClampToEdgeWrapping;
texture.wrapT = THREE.ClampToEdgeWrapping;
mesh = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { map: texture } ) );
scene.add( mesh );

}



function generateHeight( width, height ) {

var size = width * height, Terriandata = new Uint8Array( size ),
    perlin = new THREE.ImprovedNoise(), quality = 1, z = Math.random() * 100;

for ( var j = 0; j < 4; j ++ ) {

    for ( var i = 0; i < size; i ++ ) {

        var x = i % width, y = ~ ~ ( i / width );
        Terriandata[ i ] += Math.abs( perlin.noise( x / quality, y / quality, z ) * quality * 1.75 );

    }

    quality *= 5;

}

return Terriandata;

}



function generateTexture( Terriandata, width, height ) {

var canvas, canvasScaled, context, image, imageData, vector3, sun, shade;

vector3 = new THREE.Vector3( 0, 0, 0 );

sun = new THREE.Vector3( 1, 1, 1 );
sun.normalize();

canvas = document.createElement( 'canvas' );
canvas.width = width;
canvas.height = height;

context = canvas.getContext( '2d' );
context.fillStyle = '#000';
context.fillRect( 0, 0, width, height );

image = context.getImageData( 0, 0, canvas.width, canvas.height );
imageData = image.data;

for ( var i = 0, j = 0, l = imageData.length; i < l; i += 4, j ++ ) {

    vector3.x = Terriandata[ j - 2 ] - Terriandata[ j + 2 ];
    vector3.y = 2;
    vector3.z = Terriandata[ j - width * 2 ] - Terriandata[ j + width * 2 ];
    vector3.normalize();

    shade = vector3.dot( sun );

    imageData[ i ] = ( 96 + shade * 128 ) * ( 0.5 + Terriandata[ j ] * 0.007 );
    imageData[ i + 1 ] = ( 32 + shade * 96 ) * ( 0.5 + Terriandata[ j ] * 0.007 );
    imageData[ i + 2 ] = ( shade * 96 ) * ( 0.5 + Terriandata[ j ] * 0.007 );

}

context.putImageData( image, 0, 0 );

// Scaled 4x

canvasScaled = document.createElement( 'canvas' );
canvasScaled.width = width * 4;
canvasScaled.height = height * 4;

context = canvasScaled.getContext( '2d' );
context.scale( 4, 4 );
context.drawImage( canvas, 0, 0 );

image = context.getImageData( 0, 0, canvasScaled.width, canvasScaled.height );
imageData = image.data;

for ( var i = 0, l = imageData.length; i < l; i += 4 ) {

    var v = ~ ~ ( Math.random() * 5 );

    imageData[ i ] += v;
    imageData[ i + 1 ] += v;
    imageData[ i + 2 ] += v;

}

context.putImageData( image, 0, 0 );

return canvasScaled;

}

function Sky_Waterinit() {
    var waterGeometry = new THREE.PlaneBufferGeometry( 10000, 10000 );

water = new THREE.Water(
    waterGeometry,
    {
        textureWidth: 512,
        textureHeight: 512,
        waterNormals: new THREE.TextureLoader().load( 'src/images/Water_2_M_Normal.jpg', function ( texture ) {

            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;

        } ),
        alpha: 1.0,
        sunDirection: light.position.clone().normalize(),
        sunColor: 0xffffff,
        waterColor: 0x001e0f,
        distortionScale: 3.7,
        fog: scene.fog !== undefined
    }
);

water.rotation.x = - Math.PI / 2;

scene.add( water );

// Skybox

var sky = new THREE.Sky();

var uniforms = sky.material.uniforms;

uniforms[ 'turbidity' ].value = 10;
uniforms[ 'rayleigh' ].value = 2;
uniforms[ 'luminance' ].value = 1;
uniforms[ 'mieCoefficient' ].value = 0.005;
uniforms[ 'mieDirectionalG' ].value = 0.8;

var parameters = {
    distance: 400,
    inclination: 0.49,
    azimuth: 0.205
};

var cubeCamera = new THREE.CubeCamera( 0.1, 1, 512 );
cubeCamera.renderTarget.texture.generateMipmaps = true;
cubeCamera.renderTarget.texture.minFilter = THREE.LinearMipMapLinearFilter;

scene.background = cubeCamera.renderTarget;

function updateSun() {

    var theta = Math.PI * ( parameters.inclination - 0.5 );
    var phi = 2 * Math.PI * ( parameters.azimuth - 0.5 );

    light.position.x = parameters.distance * Math.cos( phi );
    light.position.y = parameters.distance * Math.sin( phi ) * Math.sin( theta );
    light.position.z = parameters.distance * Math.sin( phi ) * Math.cos( theta );

    sky.material.uniforms[ 'sunPosition' ].value = light.position.copy( light.position );
    water.material.uniforms[ 'sunDirection' ].value.copy( light.position ).normalize();

    cubeCamera.update( renderer, sky );

}

updateSun();

// GUI

var gui = new dat.GUI();

var folder = gui.addFolder( 'Sky' );
folder.add( parameters, 'inclination', 0, 0.5, 0.0001 ).onChange( updateSun );
folder.add( parameters, 'azimuth', 0, 1, 0.0001 ).onChange( updateSun );
folder.open();

var uniforms = water.material.uniforms;

var folder = gui.addFolder( 'Water' );
folder.add( uniforms.distortionScale, 'value', 0, 8, 0.1 ).name( 'distortionScale' );
folder.add( uniforms.size, 'value', 0.1, 10, 0.1 ).name( 'size' );
folder.open();

}


function Cloud_raininit() {

    let loader = new THREE.TextureLoader();
     loader.load( "src/images/cloud_black.png", function ( texture ){
     cloudGeo = new THREE.PlaneBufferGeometry(500, 500);
     cloudMaterial = new THREE.MeshBasicMaterial({
         map: texture,
         transparent: true
     })

     for(let p = 0; p < 50; p++ ){
         let cloud = new THREE.Mesh(cloudGeo, cloudMaterial);
         cloud.position.set(
              Math.random() * 800 - 400,
              500,
              Math.random() * 500 - 450
         );
         cloud.rotation.x = 1.16;
         cloud.rotation.y = -0.12;
         cloud.rotation.z = Math.random() * 360;
         cloud.material.opacity = 0.8;
         cloudParticles_b.push(cloud);
         scene.add(cloud);
     }
     });

    

    flash = new THREE.PointLight(0x062d89, 30, 500, 0);
    flash.position.set(
              10,
              125,
              -50
         );
    scene.add(flash);

    rainGeo = new THREE.Geometry();
    for(let i=0; i<rainCount;i++){
        rainDrop = new THREE.Vector3(
            Math.random() * 500 - 450,
            Math.random() * 500 - 450,
            Math.random() * 500 - 450
        );
        rainDrop.velocity = {};
        rainDrop.velocity = 0;
        rainGeo.vertices.push(rainDrop);
    }
    rainMaterial = new THREE.PointsMaterial({
        color: 0xaaaaaa,
        size: 0.1,
        transparent: true
    });
    rain = new THREE.Points(rainGeo,rainMaterial);
    scene.add(rain);
}




function animate() {
    cloudParticles_b.forEach(p =>{
     p.rotation.z -=0.002;
});
rainGeo.vertices.forEach(p=>{
    p.velocity-= 0.01 + Math.random() * 1.5;
    p.y += p.velocity;
    if (p.y < 0){
        p.y = 500;
        p.velocity = 0;
    }
});
rainGeo.verticesNeedUpdate = true;
// rain.rotation.y += 0.002;
if(Math.random() > 0.93 || flash.power > 100){
    if (flash.power < 100)
    flash.position.set(
        Math.random() * 400,
        Math.random() * 200 + 300,
        100
    );
    flash.power = 50 + Math.random() * 500

}
requestAnimationFrame( animate );
render();
stats.update();

}



function render() {
var time = performance.now() * 0.001;

controls.update( clock.getDelta() );
renderer.render( scene, camera );

water.material.uniforms[ 'time' ].value += 1.0 / 60.0;
}


</script>
</body>
</html>